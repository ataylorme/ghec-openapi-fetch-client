import createClient, { type Middleware } from "openapi-fetch";
import type { paths } from "./lib/ghec/api/types/v1.d.js"; // generated by openapi-typescript

const client = createClient<paths>({
	baseUrl: "https://api.github.com/",
	headers: {
		"X-GitHub-Api-Version": "2022-11-28",
	},
});

export const paginationMiddleware: Middleware = {
	async onResponse({ request, response }) {
		if (request.method.toUpperCase() !== "GET") {
			return undefined;
		}
		const { status } = response;
		if (status !== 200) {
			return undefined;
		}
		return getPaginatedData({ response, request });
	},
};

async function getPaginatedData({
	response,
	request,
}: { response: Response; request: Request }): Promise<Response> {
	const nextPattern = /(?<=<)([\S]*)(?=>; rel="next")/i;
	let data = await response.json();
	// Ensure accumulated data is an array
	if (!Array.isArray(data)) {
		data = parseData(data);
	}
	const { headers: resHeaders, status } = response;
	let linkHeader = response.headers.get("link") ?? "";
	let pagesRemaining = linkHeader.includes(`rel="next"`);
	let url: string = request.url;

	while (pagesRemaining) {
		try {
			// Clone the original request's headers to maintain auth and other settings
			const init: RequestInit = {
				headers: request.headers,
			};
			const newResponse = await fetch(url, init);
			if (!newResponse.ok) {
				break;
			}
			const json = await newResponse.json();
			// Flatten arrays if json returns an array; otherwise parse the object
			const newData = Array.isArray(json) ? json : parseData(json);
			data = Array.isArray(data)
				? data.concat(newData)
				: [data].concat(newData);

			linkHeader = newResponse.headers.get("link") ?? "";
			pagesRemaining = linkHeader.includes(`rel="next"`);
			if (pagesRemaining) {
				const match = linkHeader.match(nextPattern);
				if (match) {
					url = match[0];
				} else {
					break;
				}
			}
		} catch (error) {
			break;
		}
	}

	// Return proper JSON response with Content-Type header
	return new Response(JSON.stringify(data), {
		...(resHeaders && {
			headers: {
				...Object.fromEntries(resHeaders.entries()),
				"Content-Type": "application/json",
			},
		}),
		status: 200,
	});
}

// biome-ignore lint/suspicious/noExplicitAny: unknown type from openapi-fetch
function parseData(data: any): any {
	// If the data is an array, return that
	if (Array.isArray(data)) {
		return data;
	}

	// Some endpoints respond with 204 No Content instead of empty array
	//   when there is no data. In that case, return an empty array.
	if (!data) {
		return [];
	}

	// Otherwise, the array of items that we want is in an object
	// Delete keys that don't include the array of items
	// biome-ignore lint/performance/noDelete: delete unwanted GitHub keys
	delete data.incomplete_results;
	// biome-ignore lint/performance/noDelete: delete unwanted GitHub keys
	delete data.repository_selection;
	// biome-ignore lint/performance/noDelete: delete unwanted GitHub keys
	delete data.total_count;
	// Pull out the array of items
	const namespaceKey = Object.keys(data)[0];
	if (namespaceKey !== undefined) {
		// biome-ignore lint/style/noParameterAssign: reassigning data
		data = data[namespaceKey];
	}

	return data;
}

export default client;
